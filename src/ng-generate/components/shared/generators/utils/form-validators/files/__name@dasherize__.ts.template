/** <%= options.generationDisclaimerText %> **/

import {AbstractControl, FormArray, FormGroup, ValidationErrors, ValidatorFn} from '@angular/forms';
import * as charsetDetector from 'charset-detector';

export interface CustomControlValidationError {
    translationKey: string;
    translationParams: {[key: string]: any};
}

type BoundDefinition = 'OPEN' | 'AT_LEAST' | 'GREATER_THAN' | 'LESS_THAN' | 'AT_MOST';
type Encoding = 'US-ASCII' | 'ISO-8859-1' | 'UTF-8' | 'UTF-16' | 'UTF-16BE' | 'UTF-16LE';

export class FormValidators {
    static applyToChildren(validator: ValidatorFn): ValidatorFn {
        return (control: AbstractControl): ValidationErrors | null => {
            const group = control as FormGroup;
            const controls = Object.values(group.controls);

            const validationErrors = controls
                .map(c => {
                  const errors = validator(c);

                  if (errors) {
                      c.setErrors(errors);
                  }

                  return errors;
                })
                .filter(c => !!c);

            return validationErrors[0] ?? null;
        };
    }

    static uniqueValuesValidator(): ValidatorFn {
        return (control: AbstractControl): ValidationErrors | null => {
            const group = control as FormGroup;

            if (!group.value) {
                return null;
            }

            const values = Object.values(group.value).filter(value => !!value);
            const isUnique = new Set(values).size === values.length;

            return !isUnique ? {
                lengthMin: {
                    translationKey: 'validation.group_unique_values',
                    translationParams: {},
                    isGroupSpecificError: true
                },
            }
            : null;
        };
    }

    static listLengthValidator(min: number | undefined, max: number | undefined): ValidatorFn {
        return (control: AbstractControl): ValidationErrors | null => {
            const array = control as FormArray;

            if (!array.value) {
                return null;
            }

            const length = array.value.length
            const minStatement = min !== undefined ? length >= min : true;
            const maxStatement = max !== undefined ? length <= max : true;

            return !minStatement
                ? {
                    lengthMin: {
                        translationKey: 'validation.list_length_min',
                        translationParams: {
                            min
                        },
                        isGroupSpecificError: true
                    }
                }
                : !maxStatement
                ? {
                    lengthMax: {
                        translationKey: 'validation.list_length_max',
                        translationParams: {
                            max
                        },
                        isGroupSpecificError: true
                    }
                }
                : null;
        };
    }

    static deconstructionRuleValidator(rules: {name: string; rule: RegExp}[]): ValidatorFn {
        return (control: AbstractControl): ValidationErrors | null => {
            const group = control as FormGroup;

            if (!group.value) {
                return null;
            }

            const validationErrors = rules
                .map(({name, rule}) => {
                    const control = group.get(name);

                    if (!control) {
                        return null;
                    }

                    const validator = FormValidators.regularExpression(rule);
                    const errors = validator(control);

                    if (errors) {
                        control.setErrors(errors);
                    }

                    return errors;
                })
                .filter(c => !!c);

            return validationErrors[0] ?? null;
        };
    }

    static encodingValidator(encoding: Encoding): ValidatorFn {
        const error = {
            encoding: {
                translationKey: 'validation.encoding',
                translationParams: {
                    encoding
                },
            }
        };

        const utf16Validator = (control: AbstractControl): ValidationErrors | null => {
            const value = control.value;

            if (!value) {
                return null;
            }

            const encoder = new TextEncoder();
            const uint8Array = encoder.encode(value);

            const charsetMatch = charsetDetector(uint8Array);
            const utf16BeCharsetMatch = charsetMatch.find(charset => charset.charsetName === 'UTF-16BE');
            const utf16LeCharsetMatch = charsetMatch.find(charset => charset.charsetName === 'UTF-16LE');
            const isMatch = utf16BeCharsetMatch && utf16LeCharsetMatch;

            return isMatch ? null : error;
        };

        const usAsciiValidator = (control: AbstractControl): ValidationErrors | null => {
            const value = control.value;

            if (!value) {
                return null;
            }

            const pattern = /^[\x00-\x7F]*$/;
            const isMatch = pattern.test(value);

            return isMatch ? null : error;
        };

        const iso88591Validator = (control: AbstractControl): ValidationErrors | null => {
            const value = control.value;

            if (!value) {
                return null;
            }

            const pattern = /^[\x00-\xFF]*$/;
            const isMatch = pattern.test(value);

            return isMatch ? null : error;
        };

        const defaultValidator = (control: AbstractControl): ValidationErrors | null => {
            const value = control.value;

            if (!value) {
                return null;
            }

            const encoder = new TextEncoder();
            const uint8Array = encoder.encode(value);

            const charsetMatch = charsetDetector(uint8Array);
            const isMatch = !!charsetMatch.find(charset => charset.charsetName === encoding);

            return isMatch ? null : error;
        };

        return encoding === 'UTF-16'
            ? utf16Validator
            : encoding === 'US-ASCII'
            ? usAsciiValidator
            : encoding === 'ISO-8859-1'
            ? iso88591Validator
            : defaultValidator;
    }

    static fixedPointValidator(integerLength: number, scaleLength: number): ValidatorFn {
        return (control: AbstractControl): ValidationErrors | null => {
            const value = control.value;

            if (!value) {
                return null;
            }

            const stringValue = typeof value === "string"
                ? value
                : value.toString
                ? value.toString()
                : JSON.stringify(value);

            const chunks = stringValue.split('.');
            const integerValueLength = chunks[0]?.length ?? 0;
            const scaleValueLength = chunks[1]?.length ?? 0;

            return chunks.length !== 2
                ? {
                    fixedPoint: {
                        translationKey: 'validation.fixed_point_parts',
                        translationParams: {},
                    }
                }
                : integerValueLength !== integerLength
                ? {
                    fixedPoint: {
                        translationKey: 'validation.fixed_point_integer',
                        translationParams: {
                            integerLength
                        },
                    }
                }
                : scaleValueLength !== scaleLength
                ? {
                    fixedPoint: {
                        translationKey: 'validation.fixed_point_scale',
                        translationParams: {
                            scaleLength
                        },
                    }
                }
                : null;
        }
    }

    static lengthValidator(min: number | undefined, max: number | undefined): ValidatorFn {
        return (control: AbstractControl): ValidationErrors | null => {
            const value = control.value;

            if (!value) {
                return null;
            }

            const length = value.length;
            const minStatement = min !== undefined ? length >= min : true;
            const maxStatement = max !== undefined ? length <= max : true;

            return !minStatement
                ? {
                    lengthMin: {
                        translationKey: 'validation.length_min',
                        translationParams: {
                            min
                        },
                    }
                }
                : !maxStatement
                ? {
                    lengthMax: {
                        translationKey: 'validation.length_max',
                        translationParams: {
                            max
                        },
                    }
                }
                : null;
        }
    }

    static rangeValidator(
        min: number | undefined | null,
        lowerBoundDefinition: BoundDefinition,
        max: number | undefined | null,
        upperBoundDefinition: BoundDefinition
    ): ValidatorFn {
        return (control: AbstractControl): ValidationErrors | null => {
            const value = control.value;

            if (!value && value !== 0) {
                return null;
            }

            let minStatement = true;
            if (min !== undefined && min !== null) {
                minStatement =
                    lowerBoundDefinition === 'AT_LEAST' ? value >= min : lowerBoundDefinition === 'GREATER_THAN' ? value > min : true;
            }

            let maxStatement = true;
            if (max !== undefined && max !== null) {
                maxStatement =
                    upperBoundDefinition === 'AT_MOST' ? value <= max : upperBoundDefinition === 'LESS_THAN' ? value < max : true;
            }

            return !minStatement
                ? {
                    rangeMin: {
                        translationKey: lowerBoundDefinition === 'AT_LEAST' ? 'validation.range_min_inclusive' : 'validation.range_min',
                        translationParams: {
                            min
                        },
                    }
                }
                : !maxStatement
                ? {
                    rangeMax: {
                        translationKey: upperBoundDefinition === 'AT_MOST' ? 'validation.range_max_inclusive' : 'validation.range_max',
                        translationParams: {
                            max
                        },
                    }
                }
                : null
        };
    }

    static regularExpression(pattern: RegExp): ValidatorFn {
        return (control: AbstractControl): ValidationErrors | null => {
            const value = control.value;

            if (!value && value !== 0) {
                return null;
            }

            const isMatch = pattern.test(value);

            return isMatch
                ? null
                : {
                    regularExpression: {
                        translationKey: 'validation.regular_expression',
                        translationParams: {
                            pattern: pattern.source,
                        },
                    }
                  };
        };
    }
}
