/** <%= options.generationDisclaimerText %> **/
<%
  var addConfigMenu = options.componentType === 'table' && options.hasSearchBar;
%>

import {Component, EventEmitter, Input, Output, ViewChild, AfterViewInit, inject, ElementRef, HostListener, QueryList, ViewChildren, ViewEncapsulation} from '@angular/core';
import {SelectionModel} from "@angular/cdk/collections";
import { MatDialog, MatDialogRef } from '@angular/material/dialog';

<% if (options.hasFilters || (options.componentType === 'card' && options.addCommandBar)) { %>
    import {<%= classify(name) %>FilterService
        <% if (options.componentType === 'card') { %>
            , SortCard
        <% } %>
    } from './<%= dasherize(name) %>-filter.service';
<% } %>

<% if (options.componentType === 'card') { %>
    import {<%= classify(name) %>CardValues} from './<%= dasherize(name) %>.component';
<% } %>

<% if (addConfigMenu) { %>
    import {Config, EsmfConfigMenuComponent} from '@esmf/semantic-ui-schematics';
<% } %>
import {MatToolbar} from '@angular/material/toolbar';
import {MatError, MatFormField, MatHint} from '@angular/material/form-field';
import {ReactiveFormsModule} from '@angular/forms';
import {MatIcon} from '@angular/material/icon';
import {MatSelectModule} from '@angular/material/select';
import {MatTooltip} from '@angular/material/tooltip';
import {MatMenuModule, MatMenuTrigger} from '@angular/material/menu';
import {MatIconButton} from '@angular/material/button';
import {MatInput} from '@angular/material/input';
import {TranslocoDirective, TranslocoPipe} from '@jsverse/transloco';

type InitialComponentWidth = {width: number; id: string | null};

@Component({
    selector: '<%= dasherize(name) %>-command-bar',
    imports: [
      <% if (addConfigMenu) { %>
        EsmfConfigMenuComponent,
      <% } %>
      MatToolbar,
      MatFormField,
      ReactiveFormsModule,
      MatError,
      MatHint,
      MatIcon,
      MatSelectModule,
      MatTooltip,
      MatMenuModule,
      MatIconButton,
      MatInput,
      TranslocoDirective,
      TranslocoPipe
    ],
    templateUrl: './<%= dasherize(name) %>-command-bar.component.html',
    styleUrls: ['./<%= dasherize(name) %>-command-bar.component.scss'],
    encapsulation: ViewEncapsulation.None,
    host: {class: 'js-sdk-command-bar' }
})
export class <%= classify(name) %>CommandBarComponent implements AfterViewInit {
    private dialog = inject(MatDialog);
    <% if (options.hasFilters || (options.componentType === 'card' && options.addCommandBar)) { %>
      public filterService = inject(<%= classify(name) %>FilterService);
    <% } %>
    @Input() isMultipleSelectionEnabled = true;
    @Input() isToolbarActionsEnabled = true;
    @Input() selection = new SelectionModel<any>(this.isMultipleSelectionEnabled, []);
    @Input() totalItems = 0;
    @Input() searchFocused = false;
    @Input() allowedCharacters = '';
    @Input() minNumberCharacters = 2;
    @Input() maxNumberCharacters = 50;
    @Input() searchHint?: string;
    @Input() <%= options.localStorageKeyConfig %> = '';

    <% if (addConfigMenu) { %>
        @Input() configs: Config[] = [];
        @Input() hasAdvancedSearch = this.filterService.stringColumns.length > 1;
    <% } %>

    @Output() applyFilters = new EventEmitter<void>();
    @Output() reloadFilter = new EventEmitter<void>();
    @Output() exportToCsv = new EventEmitter<void>();

    <% if (options.customCommandBarActions.length > 0) { %>
        @Output() customCommandBarActionEvent = new EventEmitter<any>();
    <% } %>

    <% if (addConfigMenu) { %>
        @Output() setConfiguration = new EventEmitter<Config[]>();
        @ViewChild(EsmfConfigMenuComponent) configMenu!: EsmfConfigMenuComponent;
        @ViewChild(MatMenuTrigger) trigger!: MatMenuTrigger;
        configMenuDialogRef: MatDialogRef<EsmfConfigMenuComponent> | null = null;
    <% } %>

    <% if (options.componentType === 'card') { %>
        @Output() sorting = new EventEmitter<void>();

        <%= camelize(name) %>CardValues = Object.values(<%= classify(name) %>CardValues);
        protected readonly SortCard = SortCard;
    <% } %>

    @ViewChild('componentsContainer', { read: ElementRef, static: false })
    componentsContainer!: ElementRef;
    @ViewChildren('toolbarComp', { read: ElementRef })
    components!: QueryList<ElementRef<HTMLElement>>;
    @ViewChild('projectedToolbarActions', {read: ElementRef, static: false})
    projectedToolbarActions!: ElementRef;
    hiddenComponents: (string | null)[] = [];
    initialCompWidths : InitialComponentWidth[]= [];

    <% if (options.componentType === 'card') { %>
      constructor() {
        this.filterService.sortedProperty = this.<%= camelize(name) %>CardValues[0];
      }
    <% } %>

    <% for(let property of propValues) { %>
      <% if ((options.isEnumQuickFilter && property.isEnum) || (options.isDateQuickFilter && property.isDate) ) { %>
              @ViewChild('<%=property.propertyName %>', { static: true }) private <%=property.propertyName %>!: TemplateRef<any>;
              openInDialog<%=property.propertyName %>(){
              this.dialog.open(this.<%=property.propertyName %>);
        }
      <% } %>
     <% } %>

    triggerApplyFilters(): void {
      this.applyFilters.emit();
    }

    triggerExportToCsv(): void {
      this.exportToCsv.emit();
    }

    triggerReloadFilter(): void {
      this.reloadFilter.emit();
    }

    <% if (options.componentType === 'card') { %>
        setSortingProperty(value: string) {
            this.filterService.sortedProperty = value;
            this.sorting.emit();
        }

        setSortingDir() {
            this.filterService.sortCard = this.filterService.sortCard === SortCard.ASCENDING ? SortCard.DESCENDING : SortCard.ASCENDING;
            this.sorting.emit();
        }
    <% } %>

    <% if (addConfigMenu) { %>
        triggerSetConfiguration(config: Array<Config>): void {
          this.setConfiguration.emit(config);
        }
    <% } %>

    <% if (options.customCommandBarActions.length > 0) { %>
        executeCustomCommandBarAction(action: string) {
            this.customCommandBarActionEvent.emit({action: action})
        }
    <% } %>

    ngAfterViewInit(): void {
      const children = Array.from<HTMLElement>(this.projectedToolbarActions.nativeElement.children);
      const projectedCompWidths = children.map(comp => ({
        width: comp.clientWidth,
        id: comp.getAttribute('data-resp')
      }));

      const compWidths = this.components
        .toArray()
        .map((comp) => ({width: comp.nativeElement.clientWidth, id: comp.nativeElement.getAttribute('data-resp')}));

      if (this.initialCompWidths.length === 0) {
        const widths = [...compWidths];
        const buttonsStartIndex = widths.findIndex(w => w.id?.includes('button'));
        widths.splice(buttonsStartIndex, 0, ...projectedCompWidths);
        this.initialCompWidths = widths;
      };

      this.updateToolbarComponentsVisibility();
    }

    @HostListener('window:resize')
    onResize() {
       this.updateToolbarComponentsVisibility();
    }

  updateToolbarComponentsVisibility() {
      this.hiddenComponents = [];
      const containerWidth = this.componentsContainer.nativeElement.clientWidth;
      let usedWidth = 0;

       for (let i = 0; i < this.initialCompWidths.length; i++) {
          const buttonWidth = this.initialCompWidths[i];
          // 76 is for the width of the collapsed menu width
          if (usedWidth + buttonWidth.width + 76 >= containerWidth) {
            this.hiddenComponents.push(buttonWidth.id);
          } else {
            usedWidth += buttonWidth.width;
          }
        }
    }

    isInCollapsedMenu(id: string) {
      return this.hiddenComponents.includes(id);
    }

    <% if (addConfigMenu) { %>
      closeConfigMenu() {
        this.trigger.closeMenu();
        this.configMenuDialogRef?.close(false);
        this.configMenuDialogRef = null;
      }

      openSettingsFromCollapsed() {
        this.configMenuDialogRef = this.dialog.open(EsmfConfigMenuComponent, {
          data: {
            keyLocalStorage: this.<%= options.localStorageKeyConfig %>,
            configs: this.configs
          }
        });
        this.configMenuDialogRef.afterClosed().subscribe(result => {
          if (result) {
            this.triggerSetConfiguration(result);
          }
        });
      }
    <% } %>
}
